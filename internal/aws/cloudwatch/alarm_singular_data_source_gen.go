// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package cloudwatch

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	cctypes "github.com/hashicorp/terraform-provider-awscc/internal/types"
)

func init() {
	registry.AddDataSourceFactory("awscc_cloudwatch_alarm", alarmDataSource)
}

// alarmDataSource returns the Terraform awscc_cloudwatch_alarm data source.
// This Terraform data source corresponds to the CloudFormation AWS::CloudWatch::Alarm resource.
func alarmDataSource(ctx context.Context) (datasource.DataSource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: ActionsEnabled
		// CloudFormation resource type schema:
		//
		//	{
		//	  "default": true,
		//	  "description": "Indicates whether actions should be executed during any changes to the alarm state. The default is TRUE.",
		//	  "type": "boolean"
		//	}
		"actions_enabled": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "Indicates whether actions should be executed during any changes to the alarm state. The default is TRUE.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: AlarmActions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The list of actions to execute when this alarm transitions into an ALARM state from any other state.",
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"alarm_actions": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "The list of actions to execute when this alarm transitions into an ALARM state from any other state.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: AlarmDescription
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The description of the alarm.",
		//	  "type": "string"
		//	}
		"alarm_description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The description of the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: AlarmName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the alarm.",
		//	  "type": "string"
		//	}
		"alarm_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Arn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Amazon Resource Name is a unique name for each resource.",
		//	  "type": "string"
		//	}
		"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Amazon Resource Name is a unique name for each resource.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ComparisonOperator
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The arithmetic operation to use when comparing the specified statistic and threshold.",
		//	  "type": "string"
		//	}
		"comparison_operator": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The arithmetic operation to use when comparing the specified statistic and threshold.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DatapointsToAlarm
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The number of datapoints that must be breaching to trigger the alarm.",
		//	  "type": "integer"
		//	}
		"datapoints_to_alarm": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The number of datapoints that must be breaching to trigger the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Dimensions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The dimensions for the metric associated with the alarm. For an alarm based on a math expression, you can't specify Dimensions. Instead, you use Metrics.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "Dimensions are arbitrary name/value pairs that can be associated with a CloudWatch metric.",
		//	    "properties": {
		//	      "Name": {
		//	        "description": "The name of the dimension.",
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the dimension.",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Value",
		//	      "Name"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"dimensions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Name
					"name": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The name of the dimension.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the dimension.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			CustomType:  cctypes.NewMultisetTypeOf[types.Object](ctx),
			Description: "The dimensions for the metric associated with the alarm. For an alarm based on a math expression, you can't specify Dimensions. Instead, you use Metrics.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: EvaluateLowSampleCountPercentile
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Used only for alarms based on percentiles.",
		//	  "type": "string"
		//	}
		"evaluate_low_sample_count_percentile": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Used only for alarms based on percentiles.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: EvaluationPeriods
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The number of periods over which data is compared to the specified threshold.",
		//	  "type": "integer"
		//	}
		"evaluation_periods": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The number of periods over which data is compared to the specified threshold.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ExtendedStatistic
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.",
		//	  "type": "string"
		//	}
		"extended_statistic": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: InsufficientDataActions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state.",
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"insufficient_data_actions": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "The actions to execute when this alarm transitions to the INSUFFICIENT_DATA state from any other state.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: MetricName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the metric associated with the alarm.",
		//	  "type": "string"
		//	}
		"metric_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the metric associated with the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Metrics
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "An array that enables you to create an alarm based on the result of a metric math expression.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "This property type specifies the metric data to return, and whether this call is just retrieving a batch set of data for one metric, or is performing a math expression on metric data.",
		//	    "properties": {
		//	      "AccountId": {
		//	        "description": "The ID of the account where the metrics are located, if this is a cross-account alarm.",
		//	        "type": "string"
		//	      },
		//	      "Expression": {
		//	        "description": "The math expression to be performed on the returned data.",
		//	        "type": "string"
		//	      },
		//	      "Id": {
		//	        "description": "A short name used to tie this object to the results in the response.",
		//	        "type": "string"
		//	      },
		//	      "Label": {
		//	        "description": "A human-readable label for this metric or expression.",
		//	        "type": "string"
		//	      },
		//	      "MetricStat": {
		//	        "additionalProperties": false,
		//	        "description": "The metric to be returned, along with statistics, period, and units.",
		//	        "properties": {
		//	          "Metric": {
		//	            "additionalProperties": false,
		//	            "description": "The metric to return, including the metric name, namespace, and dimensions.",
		//	            "properties": {
		//	              "Dimensions": {
		//	                "description": "The dimensions for the metric.",
		//	                "insertionOrder": false,
		//	                "items": {
		//	                  "additionalProperties": false,
		//	                  "description": "Dimensions are arbitrary name/value pairs that can be associated with a CloudWatch metric.",
		//	                  "properties": {
		//	                    "Name": {
		//	                      "description": "The name of the dimension.",
		//	                      "type": "string"
		//	                    },
		//	                    "Value": {
		//	                      "description": "The value for the dimension.",
		//	                      "type": "string"
		//	                    }
		//	                  },
		//	                  "required": [
		//	                    "Value",
		//	                    "Name"
		//	                  ],
		//	                  "type": "object"
		//	                },
		//	                "type": "array",
		//	                "uniqueItems": false
		//	              },
		//	              "MetricName": {
		//	                "description": "The name of the metric.",
		//	                "type": "string"
		//	              },
		//	              "Namespace": {
		//	                "description": "The namespace of the metric.",
		//	                "type": "string"
		//	              }
		//	            },
		//	            "type": "object"
		//	          },
		//	          "Period": {
		//	            "description": "The granularity, in seconds, of the returned data points.",
		//	            "type": "integer"
		//	          },
		//	          "Stat": {
		//	            "description": "The statistic to return.",
		//	            "type": "string"
		//	          },
		//	          "Unit": {
		//	            "description": "The unit to use for the returned data points.",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "required": [
		//	          "Stat",
		//	          "Period",
		//	          "Metric"
		//	        ],
		//	        "type": "object"
		//	      },
		//	      "Period": {
		//	        "description": "The period in seconds, over which the statistic is applied.",
		//	        "type": "integer"
		//	      },
		//	      "ReturnData": {
		//	        "description": "This option indicates whether to return the timestamps and raw data values of this metric.",
		//	        "type": "boolean"
		//	      }
		//	    },
		//	    "required": [
		//	      "Id"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"metrics": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: AccountId
					"account_id": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The ID of the account where the metrics are located, if this is a cross-account alarm.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Expression
					"expression": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The math expression to be performed on the returned data.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Id
					"id": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A short name used to tie this object to the results in the response.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Label
					"label": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "A human-readable label for this metric or expression.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: MetricStat
					"metric_stat": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Metric
							"metric": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
								Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
									// Property: Dimensions
									"dimensions": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
										NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
											Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
												// Property: Name
												"name": schema.StringAttribute{ /*START ATTRIBUTE*/
													Description: "The name of the dimension.",
													Computed:    true,
												}, /*END ATTRIBUTE*/
												// Property: Value
												"value": schema.StringAttribute{ /*START ATTRIBUTE*/
													Description: "The value for the dimension.",
													Computed:    true,
												}, /*END ATTRIBUTE*/
											}, /*END SCHEMA*/
										}, /*END NESTED OBJECT*/
										CustomType:  cctypes.NewMultisetTypeOf[types.Object](ctx),
										Description: "The dimensions for the metric.",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: MetricName
									"metric_name": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The name of the metric.",
										Computed:    true,
									}, /*END ATTRIBUTE*/
									// Property: Namespace
									"namespace": schema.StringAttribute{ /*START ATTRIBUTE*/
										Description: "The namespace of the metric.",
										Computed:    true,
									}, /*END ATTRIBUTE*/
								}, /*END SCHEMA*/
								Description: "The metric to return, including the metric name, namespace, and dimensions.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Period
							"period": schema.Int64Attribute{ /*START ATTRIBUTE*/
								Description: "The granularity, in seconds, of the returned data points.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Stat
							"stat": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The statistic to return.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
							// Property: Unit
							"unit": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The unit to use for the returned data points.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
						Description: "The metric to be returned, along with statistics, period, and units.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: Period
					"period": schema.Int64Attribute{ /*START ATTRIBUTE*/
						Description: "The period in seconds, over which the statistic is applied.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: ReturnData
					"return_data": schema.BoolAttribute{ /*START ATTRIBUTE*/
						Description: "This option indicates whether to return the timestamps and raw data values of this metric.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "An array that enables you to create an alarm based on the result of a metric math expression.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Namespace
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The namespace of the metric associated with the alarm.",
		//	  "type": "string"
		//	}
		"namespace": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The namespace of the metric associated with the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: OKActions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The actions to execute when this alarm transitions to the OK state from any other state.",
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"ok_actions": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "The actions to execute when this alarm transitions to the OK state from any other state.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Period
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The period in seconds, over which the statistic is applied.",
		//	  "type": "integer"
		//	}
		"period": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The period in seconds, over which the statistic is applied.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Statistic
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The statistic for the metric associated with the alarm, other than percentile.",
		//	  "type": "string"
		//	}
		"statistic": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The statistic for the metric associated with the alarm, other than percentile.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Threshold
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "In an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.",
		//	  "type": "number"
		//	}
		"threshold": schema.Float64Attribute{ /*START ATTRIBUTE*/
			Description: "In an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ThresholdMetricId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "In an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.",
		//	  "type": "string"
		//	}
		"threshold_metric_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "In an alarm based on an anomaly detection model, this is the ID of the ANOMALY_DETECTION_BAND function used as the threshold for the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: TreatMissingData
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Sets how this alarm is to handle missing data points. Valid values are breaching, notBreaching, ignore, and missing.",
		//	  "type": "string"
		//	}
		"treat_missing_data": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Sets how this alarm is to handle missing data points. Valid values are breaching, notBreaching, ignore, and missing.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Unit
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The unit of the metric associated with the alarm.",
		//	  "type": "string"
		//	}
		"unit": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The unit of the metric associated with the alarm.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Required:    true,
	}

	schema := schema.Schema{
		Description: "Data Source schema for AWS::CloudWatch::Alarm",
		Attributes:  attributes,
	}

	var opts generic.DataSourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::CloudWatch::Alarm").WithTerraformTypeName("awscc_cloudwatch_alarm")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"account_id":                           "AccountId",
		"actions_enabled":                      "ActionsEnabled",
		"alarm_actions":                        "AlarmActions",
		"alarm_description":                    "AlarmDescription",
		"alarm_name":                           "AlarmName",
		"arn":                                  "Arn",
		"comparison_operator":                  "ComparisonOperator",
		"datapoints_to_alarm":                  "DatapointsToAlarm",
		"dimensions":                           "Dimensions",
		"evaluate_low_sample_count_percentile": "EvaluateLowSampleCountPercentile",
		"evaluation_periods":                   "EvaluationPeriods",
		"expression":                           "Expression",
		"extended_statistic":                   "ExtendedStatistic",
		"id":                                   "Id",
		"insufficient_data_actions":            "InsufficientDataActions",
		"label":                                "Label",
		"metric":                               "Metric",
		"metric_name":                          "MetricName",
		"metric_stat":                          "MetricStat",
		"metrics":                              "Metrics",
		"name":                                 "Name",
		"namespace":                            "Namespace",
		"ok_actions":                           "OKActions",
		"period":                               "Period",
		"return_data":                          "ReturnData",
		"stat":                                 "Stat",
		"statistic":                            "Statistic",
		"threshold":                            "Threshold",
		"threshold_metric_id":                  "ThresholdMetricId",
		"treat_missing_data":                   "TreatMissingData",
		"unit":                                 "Unit",
		"value":                                "Value",
	})

	v, err := generic.NewSingularDataSource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
