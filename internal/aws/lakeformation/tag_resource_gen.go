// Code generated by generators/resource/main.go; DO NOT EDIT.

package lakeformation

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	. "github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	"github.com/hashicorp/terraform-provider-awscc/internal/validate"
)

func init() {
	registry.AddResourceFactory("awscc_lakeformation_tag", tagResource)
}

// tagResource returns the Terraform awscc_lakeformation_tag resource.
// This Terraform resource corresponds to the CloudFormation AWS::LakeFormation::Tag resource.
func tagResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]tfsdk.Attribute{
		"catalog_id": {
			// Property: CatalogId
			// CloudFormation resource type schema:
			//
			//	{
			//	  "description": "The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.",
			//	  "maxLength": 12,
			//	  "minLength": 12,
			//	  "type": "string"
			//	}
			Description: "The identifier for the Data Catalog. By default, the account ID. The Data Catalog is the persistent metadata store. It contains database definitions, table definitions, and other control information to manage your Lake Formation environment.",
			Type:        types.StringType,
			Optional:    true,
			Computed:    true,
			Validators: []tfsdk.AttributeValidator{
				validate.StringLenBetween(12, 12),
			},
			PlanModifiers: []tfsdk.AttributePlanModifier{
				resource.UseStateForUnknown(),
				resource.RequiresReplace(),
			},
		},
		"tag_key": {
			// Property: TagKey
			// CloudFormation resource type schema:
			//
			//	{
			//	  "description": "The key-name for the LF-tag.",
			//	  "maxLength": 128,
			//	  "minLength": 1,
			//	  "pattern": "^([{a-zA-Z}{\\s}{0-9}_.:\\/=+\\-@%]*)$",
			//	  "type": "string"
			//	}
			Description: "The key-name for the LF-tag.",
			Type:        types.StringType,
			Required:    true,
			Validators: []tfsdk.AttributeValidator{
				validate.StringLenBetween(1, 128),
				validate.StringMatch(regexp.MustCompile("^([{a-zA-Z}{\\s}{0-9}_.:\\/=+\\-@%]*)$"), ""),
			},
			PlanModifiers: []tfsdk.AttributePlanModifier{
				resource.RequiresReplace(),
			},
		},
		"tag_values": {
			// Property: TagValues
			// CloudFormation resource type schema:
			//
			//	{
			//	  "description": "A list of possible values an attribute can take.",
			//	  "insertionOrder": false,
			//	  "items": {
			//	    "maxLength": 256,
			//	    "minLength": 0,
			//	    "pattern": "^([{a-zA-Z}{\\s}{0-9}_.:\\*\\/=+\\-@%]*)$",
			//	    "type": "string"
			//	  },
			//	  "maxItems": 50,
			//	  "minItems": 1,
			//	  "type": "array"
			//	}
			Description: "A list of possible values an attribute can take.",
			Type:        types.ListType{ElemType: types.StringType},
			Required:    true,
			Validators: []tfsdk.AttributeValidator{
				validate.ArrayLenBetween(1, 50),
				validate.ArrayForEach(validate.StringLenBetween(0, 256)),
				validate.ArrayForEach(validate.StringMatch(regexp.MustCompile("^([{a-zA-Z}{\\s}{0-9}_.:\\*\\/=+\\-@%]*)$"), "")),
			},
			PlanModifiers: []tfsdk.AttributePlanModifier{
				Multiset(),
			},
		},
	}

	attributes["id"] = tfsdk.Attribute{
		Description: "Uniquely identifies the resource.",
		Type:        types.StringType,
		Computed:    true,
		PlanModifiers: []tfsdk.AttributePlanModifier{
			resource.UseStateForUnknown(),
		},
	}

	schema := tfsdk.Schema{
		Description: "A resource schema representing a Lake Formation Tag.",
		Version:     1,
		Attributes:  attributes,
	}

	var opts ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::LakeFormation::Tag").WithTerraformTypeName("awscc_lakeformation_tag")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithSyntheticIDAttribute(true)
	opts = opts.WithAttributeNameMap(map[string]string{
		"catalog_id": "CatalogId",
		"tag_key":    "TagKey",
		"tag_values": "TagValues",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
