// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package lambda

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
	"regexp"
)

func init() {
	registry.AddResourceFactory("awscc_lambda_function", functionResource)
}

// functionResource returns the Terraform awscc_lambda_function resource.
// This Terraform resource corresponds to the CloudFormation AWS::Lambda::Function resource.
func functionResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: Architectures
		// CloudFormation resource type schema:
		//
		//	{
		//	  "items": {
		//	    "enum": [
		//	      "x86_64",
		//	      "arm64"
		//	    ],
		//	    "type": "string"
		//	  },
		//	  "maxItems": 1,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"architectures": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeBetween(1, 1),
				listvalidator.UniqueValues(),
				listvalidator.ValueStringsAre(
					stringvalidator.OneOf(
						"x86_64",
						"arm64",
					),
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Arn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Unique identifier for function resources",
		//	  "type": "string"
		//	}
		"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Unique identifier for function resources",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Code
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The code for the function.",
		//	  "properties": {
		//	    "ImageUri": {
		//	      "description": "ImageUri.",
		//	      "type": "string"
		//	    },
		//	    "S3Bucket": {
		//	      "description": "An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.",
		//	      "maxLength": 63,
		//	      "minLength": 3,
		//	      "pattern": "",
		//	      "type": "string"
		//	    },
		//	    "S3Key": {
		//	      "description": "The Amazon S3 key of the deployment package.",
		//	      "maxLength": 1024,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    },
		//	    "S3ObjectVersion": {
		//	      "description": "For versioned objects, the version of the deployment package object to use.",
		//	      "maxLength": 1024,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    },
		//	    "ZipFile": {
		//	      "description": "The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"code": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ImageUri
				"image_uri": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "ImageUri.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// ImageUri is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: S3Bucket
				"s3_bucket": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(3, 63),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// S3Bucket is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: S3Key
				"s3_key": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The Amazon S3 key of the deployment package.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 1024),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// S3Key is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: S3ObjectVersion
				"s3_object_version": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "For versioned objects, the version of the deployment package object to use.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 1024),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// S3ObjectVersion is a write-only property.
				}, /*END ATTRIBUTE*/
				// Property: ZipFile
				"zip_file": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The source code of your Lambda function. If you include your function source inline with this parameter, AWS CloudFormation places it in a file named index and zips it to create a deployment package..",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
					// ZipFile is a write-only property.
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The code for the function.",
			Required:    true,
			// Code is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: CodeSigningConfigArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A unique Arn for CodeSigningConfig resource",
		//	  "pattern": "arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}",
		//	  "type": "string"
		//	}
		"code_signing_config_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A unique Arn for CodeSigningConfig resource",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("arn:(aws[a-zA-Z-]*)?:lambda:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:code-signing-config:csc-[a-z0-9]{17}"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DeadLetterConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing.",
		//	  "properties": {
		//	    "TargetArn": {
		//	      "description": "The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.",
		//	      "pattern": "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"dead_letter_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: TargetArn
				"target_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.RegexMatches(regexp.MustCompile("^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A description of the function.",
		//	  "maxLength": 256,
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "A description of the function.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthAtMost(256),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Environment
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Environment variables that are accessible from function code during execution.",
		//	  "properties": {
		//	    "Variables": {
		//	      "additionalProperties": false,
		//	      "description": "Environment variable key-value pairs.",
		//	      "patternProperties": {
		//	        "": {
		//	          "type": "string"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"environment": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Variables
				"variables":         // Pattern: ""
				schema.MapAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "Environment variable key-value pairs.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Map{ /*START PLAN MODIFIERS*/
						mapplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Environment variables that are accessible from function code during execution.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: EphemeralStorage
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "A function's ephemeral storage settings.",
		//	  "properties": {
		//	    "Size": {
		//	      "description": "The amount of ephemeral storage that your function has access to.",
		//	      "maximum": 10240,
		//	      "minimum": 512,
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "required": [
		//	    "Size"
		//	  ],
		//	  "type": "object"
		//	}
		"ephemeral_storage": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Size
				"size": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The amount of ephemeral storage that your function has access to.",
					Required:    true,
					Validators: []validator.Int64{ /*START VALIDATORS*/
						int64validator.Between(512, 10240),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "A function's ephemeral storage settings.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FileSystemConfigs
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Connection settings for an Amazon EFS file system. To connect a function to a file system, a mount target must be available in every Availability Zone that your function connects to. If your template contains an AWS::EFS::MountTarget resource, you must also specify a DependsOn attribute to ensure that the mount target is created or updated before the function.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Arn": {
		//	        "description": "The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.",
		//	        "maxLength": 200,
		//	        "pattern": "^arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:access-point/fsap-[a-f0-9]{17}$",
		//	        "type": "string"
		//	      },
		//	      "LocalMountPath": {
		//	        "description": "The path where the function can access the file system, starting with /mnt/.",
		//	        "maxLength": 160,
		//	        "pattern": "^/mnt/[a-zA-Z0-9-_.]+$",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Arn",
		//	      "LocalMountPath"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "maxItems": 1,
		//	  "type": "array"
		//	}
		"file_system_configs": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Arn
					"arn": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthAtMost(200),
							stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws[a-zA-Z-]*:elasticfilesystem:[a-z]{2}((-gov)|(-iso(b?)))?-[a-z]+-\\d{1}:\\d{12}:access-point/fsap-[a-f0-9]{17}$"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: LocalMountPath
					"local_mount_path": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The path where the function can access the file system, starting with /mnt/.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthAtMost(160),
							stringvalidator.RegexMatches(regexp.MustCompile("^/mnt/[a-zA-Z0-9-_.]+$"), ""),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "Connection settings for an Amazon EFS file system. To connect a function to a file system, a mount target must be available in every Availability Zone that your function connects to. If your template contains an AWS::EFS::MountTarget resource, you must also specify a DependsOn attribute to ensure that the mount target is created or updated before the function.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.List{ /*START VALIDATORS*/
				listvalidator.SizeAtMost(1),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FunctionName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the Lambda function, up to 64 characters in length. If you don't specify a name, AWS CloudFormation generates one.",
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"function_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the Lambda function, up to 64 characters in length. If you don't specify a name, AWS CloudFormation generates one.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthAtLeast(1),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Handler
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime",
		//	  "maxLength": 128,
		//	  "pattern": "^[^\\s]+$",
		//	  "type": "string"
		//	}
		"handler": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthAtMost(128),
				stringvalidator.RegexMatches(regexp.MustCompile("^[^\\s]+$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ImageConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "ImageConfig",
		//	  "properties": {
		//	    "Command": {
		//	      "description": "Command.",
		//	      "items": {
		//	        "type": "string"
		//	      },
		//	      "maxItems": 1500,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "EntryPoint": {
		//	      "description": "EntryPoint.",
		//	      "items": {
		//	        "type": "string"
		//	      },
		//	      "maxItems": 1500,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    },
		//	    "WorkingDirectory": {
		//	      "description": "WorkingDirectory.",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"image_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Command
				"command": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "Command.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeAtMost(1500),
						listvalidator.UniqueValues(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: EntryPoint
				"entry_point": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "EntryPoint.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeAtMost(1500),
						listvalidator.UniqueValues(),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: WorkingDirectory
				"working_directory": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "WorkingDirectory.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "ImageConfig",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: KmsKeyArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment variables. If it's not provided, AWS Lambda uses a default service key.",
		//	  "pattern": "^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$",
		//	  "type": "string"
		//	}
		"kms_key_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment variables. If it's not provided, AWS Lambda uses a default service key.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("^(arn:(aws[a-zA-Z-]*)?:[a-z0-9-.]+:.*)|()$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Layers
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list of function layers to add to the function's execution environment. Specify each layer by its ARN, including the version.",
		//	  "items": {
		//	    "type": "string"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": false
		//	}
		"layers": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "A list of function layers to add to the function's execution environment. Specify each layer by its ARN, including the version.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: LoggingConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The logging configuration of your function",
		//	  "properties": {
		//	    "ApplicationLogLevel": {
		//	      "description": "Application log granularity level, can only be used when LogFormat is set to JSON",
		//	      "enum": [
		//	        "TRACE",
		//	        "DEBUG",
		//	        "INFO",
		//	        "WARN",
		//	        "ERROR",
		//	        "FATAL"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "LogFormat": {
		//	      "description": "Log delivery format for the lambda function",
		//	      "enum": [
		//	        "Text",
		//	        "JSON"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "LogGroup": {
		//	      "description": "The log group name.",
		//	      "maxLength": 512,
		//	      "minLength": 1,
		//	      "pattern": "[\\.\\-_/#A-Za-z0-9]+",
		//	      "type": "string"
		//	    },
		//	    "SystemLogLevel": {
		//	      "description": "System log granularity level, can only be used when LogFormat is set to JSON",
		//	      "enum": [
		//	        "DEBUG",
		//	        "INFO",
		//	        "WARN"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"logging_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ApplicationLogLevel
				"application_log_level": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Application log granularity level, can only be used when LogFormat is set to JSON",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"TRACE",
							"DEBUG",
							"INFO",
							"WARN",
							"ERROR",
							"FATAL",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: LogFormat
				"log_format": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Log delivery format for the lambda function",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"Text",
							"JSON",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: LogGroup
				"log_group": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The log group name.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 512),
						stringvalidator.RegexMatches(regexp.MustCompile("[\\.\\-_/#A-Za-z0-9]+"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: SystemLogLevel
				"system_log_level": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "System log granularity level, can only be used when LogFormat is set to JSON",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"DEBUG",
							"INFO",
							"WARN",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The logging configuration of your function",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: MemorySize
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The amount of memory that your function has access to. Increasing the function's memory also increases its CPU allocation. The default value is 128 MB. The value must be a multiple of 64 MB.",
		//	  "type": "integer"
		//	}
		"memory_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The amount of memory that your function has access to. Increasing the function's memory also increases its CPU allocation. The default value is 128 MB. The value must be a multiple of 64 MB.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: PackageType
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "PackageType.",
		//	  "enum": [
		//	    "Image",
		//	    "Zip"
		//	  ],
		//	  "type": "string"
		//	}
		"package_type": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "PackageType.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"Image",
					"Zip",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: ReservedConcurrentExecutions
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The number of simultaneous executions to reserve for the function.",
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"reserved_concurrent_executions": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The number of simultaneous executions to reserve for the function.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.AtLeast(0),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Role
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) of the function's execution role.",
		//	  "pattern": "^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$",
		//	  "type": "string"
		//	}
		"role": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) of the function's execution role.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("^arn:(aws[a-zA-Z-]*)?:iam::\\d{12}:role/?[a-zA-Z_0-9+=,.@\\-_/]+$"), ""),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: Runtime
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The identifier of the function's runtime.",
		//	  "type": "string"
		//	}
		"runtime": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The identifier of the function's runtime.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: RuntimeManagementConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "RuntimeManagementConfig",
		//	  "properties": {
		//	    "RuntimeVersionArn": {
		//	      "description": "Unique identifier for a runtime version arn",
		//	      "type": "string"
		//	    },
		//	    "UpdateRuntimeOn": {
		//	      "description": "Trigger for runtime update",
		//	      "enum": [
		//	        "Auto",
		//	        "FunctionUpdate",
		//	        "Manual"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "UpdateRuntimeOn"
		//	  ],
		//	  "type": "object"
		//	}
		"runtime_management_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: RuntimeVersionArn
				"runtime_version_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Unique identifier for a runtime version arn",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: UpdateRuntimeOn
				"update_runtime_on": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Trigger for runtime update",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"Auto",
							"FunctionUpdate",
							"Manual",
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "RuntimeManagementConfig",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: SnapStart
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The SnapStart setting of your function",
		//	  "properties": {
		//	    "ApplyOn": {
		//	      "description": "Applying SnapStart setting on function resource type.",
		//	      "enum": [
		//	        "PublishedVersions",
		//	        "None"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "ApplyOn"
		//	  ],
		//	  "type": "object"
		//	}
		"snap_start": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ApplyOn
				"apply_on": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Applying SnapStart setting on function resource type.",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"PublishedVersions",
							"None",
						),
					}, /*END VALIDATORS*/
					// ApplyOn is a write-only property.
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The SnapStart setting of your function",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
			// SnapStart is a write-only property.
		}, /*END ATTRIBUTE*/
		// Property: SnapStartResponse
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The SnapStart response of your function",
		//	  "properties": {
		//	    "ApplyOn": {
		//	      "description": "Applying SnapStart setting on function resource type.",
		//	      "enum": [
		//	        "PublishedVersions",
		//	        "None"
		//	      ],
		//	      "type": "string"
		//	    },
		//	    "OptimizationStatus": {
		//	      "description": "Indicates whether SnapStart is activated for the specified function version.",
		//	      "enum": [
		//	        "On",
		//	        "Off"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"snap_start_response": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ApplyOn
				"apply_on": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Applying SnapStart setting on function resource type.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: OptimizationStatus
				"optimization_status": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Indicates whether SnapStart is activated for the specified function version.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The SnapStart response of your function",
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Tags
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list of tags to apply to the function.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "properties": {
		//	      "Key": {
		//	        "description": "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
		//	        "maxLength": 128,
		//	        "minLength": 1,
		//	        "type": "string"
		//	      },
		//	      "Value": {
		//	        "description": "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
		//	        "maxLength": 256,
		//	        "minLength": 0,
		//	        "type": "string"
		//	      }
		//	    },
		//	    "required": [
		//	      "Key"
		//	    ],
		//	    "type": "object"
		//	  },
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"tags": schema.SetNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Key
					"key": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
						Required:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(1, 128),
						}, /*END VALIDATORS*/
					}, /*END ATTRIBUTE*/
					// Property: Value
					"value": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{ /*START VALIDATORS*/
							stringvalidator.LengthBetween(0, 256),
						}, /*END VALIDATORS*/
						PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
							stringplanmodifier.UseStateForUnknown(),
						}, /*END PLAN MODIFIERS*/
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A list of tags to apply to the function.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Set{ /*START PLAN MODIFIERS*/
				setplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Timeout
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds.",
		//	  "minimum": 1,
		//	  "type": "integer"
		//	}
		"timeout": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.Int64{ /*START VALIDATORS*/
				int64validator.AtLeast(1),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.Int64{ /*START PLAN MODIFIERS*/
				int64planmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: TracingConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Set Mode to Active to sample and trace a subset of incoming requests with AWS X-Ray.",
		//	  "properties": {
		//	    "Mode": {
		//	      "description": "The tracing mode.",
		//	      "enum": [
		//	        "Active",
		//	        "PassThrough"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"tracing_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Mode
				"mode": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The tracing mode.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"Active",
							"PassThrough",
						),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Set Mode to Active to sample and trace a subset of incoming requests with AWS X-Ray.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: VpcConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.",
		//	  "properties": {
		//	    "Ipv6AllowedForDualStack": {
		//	      "description": "A boolean indicating whether IPv6 protocols will be allowed for dual stack subnets",
		//	      "type": "boolean"
		//	    },
		//	    "SecurityGroupIds": {
		//	      "description": "A list of VPC security groups IDs.",
		//	      "items": {
		//	        "type": "string"
		//	      },
		//	      "maxItems": 5,
		//	      "type": "array",
		//	      "uniqueItems": false
		//	    },
		//	    "SubnetIds": {
		//	      "description": "A list of VPC subnet IDs.",
		//	      "items": {
		//	        "type": "string"
		//	      },
		//	      "maxItems": 16,
		//	      "type": "array",
		//	      "uniqueItems": false
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"vpc_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Ipv6AllowedForDualStack
				"ipv_6_allowed_for_dual_stack": schema.BoolAttribute{ /*START ATTRIBUTE*/
					Description: "A boolean indicating whether IPv6 protocols will be allowed for dual stack subnets",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Bool{ /*START PLAN MODIFIERS*/
						boolplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: SecurityGroupIds
				"security_group_ids": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "A list of VPC security groups IDs.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeAtMost(5),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
				// Property: SubnetIds
				"subnet_ids": schema.ListAttribute{ /*START ATTRIBUTE*/
					ElementType: types.StringType,
					Description: "A list of VPC subnet IDs.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.List{ /*START VALIDATORS*/
						listvalidator.SizeAtMost(16),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
						listplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Resource Type definition for AWS::Lambda::Function in region",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::Lambda::Function").WithTerraformTypeName("awscc_lambda_function")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithSyntheticIDAttribute(true)
	opts = opts.WithAttributeNameMap(map[string]string{
		"application_log_level":          "ApplicationLogLevel",
		"apply_on":                       "ApplyOn",
		"architectures":                  "Architectures",
		"arn":                            "Arn",
		"code":                           "Code",
		"code_signing_config_arn":        "CodeSigningConfigArn",
		"command":                        "Command",
		"dead_letter_config":             "DeadLetterConfig",
		"description":                    "Description",
		"entry_point":                    "EntryPoint",
		"environment":                    "Environment",
		"ephemeral_storage":              "EphemeralStorage",
		"file_system_configs":            "FileSystemConfigs",
		"function_name":                  "FunctionName",
		"handler":                        "Handler",
		"image_config":                   "ImageConfig",
		"image_uri":                      "ImageUri",
		"ipv_6_allowed_for_dual_stack":   "Ipv6AllowedForDualStack",
		"key":                            "Key",
		"kms_key_arn":                    "KmsKeyArn",
		"layers":                         "Layers",
		"local_mount_path":               "LocalMountPath",
		"log_format":                     "LogFormat",
		"log_group":                      "LogGroup",
		"logging_config":                 "LoggingConfig",
		"memory_size":                    "MemorySize",
		"mode":                           "Mode",
		"optimization_status":            "OptimizationStatus",
		"package_type":                   "PackageType",
		"reserved_concurrent_executions": "ReservedConcurrentExecutions",
		"role":                           "Role",
		"runtime":                        "Runtime",
		"runtime_management_config":      "RuntimeManagementConfig",
		"runtime_version_arn":            "RuntimeVersionArn",
		"s3_bucket":                      "S3Bucket",
		"s3_key":                         "S3Key",
		"s3_object_version":              "S3ObjectVersion",
		"security_group_ids":             "SecurityGroupIds",
		"size":                           "Size",
		"snap_start":                     "SnapStart",
		"snap_start_response":            "SnapStartResponse",
		"subnet_ids":                     "SubnetIds",
		"system_log_level":               "SystemLogLevel",
		"tags":                           "Tags",
		"target_arn":                     "TargetArn",
		"timeout":                        "Timeout",
		"tracing_config":                 "TracingConfig",
		"update_runtime_on":              "UpdateRuntimeOn",
		"value":                          "Value",
		"variables":                      "Variables",
		"vpc_config":                     "VpcConfig",
		"working_directory":              "WorkingDirectory",
		"zip_file":                       "ZipFile",
	})

	opts = opts.WithWriteOnlyPropertyPaths([]string{
		"/properties/SnapStart",
		"/properties/SnapStart/ApplyOn",
		"/properties/Code",
		"/properties/Code/ImageUri",
		"/properties/Code/S3Bucket",
		"/properties/Code/S3Key",
		"/properties/Code/S3ObjectVersion",
		"/properties/Code/ZipFile",
	})
	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
