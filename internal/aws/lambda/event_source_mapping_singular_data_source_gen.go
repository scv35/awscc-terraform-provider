// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package lambda

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddDataSourceFactory("awscc_lambda_event_source_mapping", eventSourceMappingDataSource)
}

// eventSourceMappingDataSource returns the Terraform awscc_lambda_event_source_mapping data source.
// This Terraform data source corresponds to the CloudFormation AWS::Lambda::EventSourceMapping resource.
func eventSourceMappingDataSource(ctx context.Context) (datasource.DataSource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: AmazonManagedKafkaEventSourceConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Specific configuration settings for an MSK event source.",
		//	  "properties": {
		//	    "ConsumerGroupId": {
		//	      "description": "The identifier for the Kafka Consumer Group to join.",
		//	      "maxLength": 200,
		//	      "minLength": 1,
		//	      "pattern": "[a-zA-Z0-9-\\/*:_+=.@-]*",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"amazon_managed_kafka_event_source_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ConsumerGroupId
				"consumer_group_id": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The identifier for the Kafka Consumer Group to join.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Specific configuration settings for an MSK event source.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: BatchSize
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The maximum number of items to retrieve in a single batch.",
		//	  "maximum": 10000,
		//	  "minimum": 1,
		//	  "type": "integer"
		//	}
		"batch_size": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "The maximum number of items to retrieve in a single batch.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: BisectBatchOnFunctionError
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Streams) If the function returns an error, split the batch in two and retry.",
		//	  "type": "boolean"
		//	}
		"bisect_batch_on_function_error": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "(Streams) If the function returns an error, split the batch in two and retry.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DestinationConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.",
		//	  "properties": {
		//	    "OnFailure": {
		//	      "additionalProperties": false,
		//	      "description": "The destination configuration for failed invocations.",
		//	      "properties": {
		//	        "Destination": {
		//	          "description": "The Amazon Resource Name (ARN) of the destination resource.",
		//	          "maxLength": 1024,
		//	          "minLength": 12,
		//	          "pattern": "arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)",
		//	          "type": "string"
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"destination_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: OnFailure
				"on_failure": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: Destination
						"destination": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The Amazon Resource Name (ARN) of the destination resource.",
							Computed:    true,
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "The destination configuration for failed invocations.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: DocumentDBEventSourceConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Document db event source config.",
		//	  "properties": {
		//	    "CollectionName": {
		//	      "description": "The collection name to connect to.",
		//	      "maxLength": 57,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    },
		//	    "DatabaseName": {
		//	      "description": "The database name to connect to.",
		//	      "maxLength": 63,
		//	      "minLength": 1,
		//	      "type": "string"
		//	    },
		//	    "FullDocument": {
		//	      "description": "Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.",
		//	      "enum": [
		//	        "UpdateLookup",
		//	        "Default"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"document_db_event_source_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: CollectionName
				"collection_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The collection name to connect to.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: DatabaseName
				"database_name": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The database name to connect to.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
				// Property: FullDocument
				"full_document": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "Include full document in change stream response. The default option will only send the changes made to documents to Lambda. If you want the complete document sent to Lambda, set this to UpdateLookup.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Document db event source config.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Enabled
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Disables the event source mapping to pause polling and invocation.",
		//	  "type": "boolean"
		//	}
		"enabled": schema.BoolAttribute{ /*START ATTRIBUTE*/
			Description: "Disables the event source mapping to pause polling and invocation.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: EventSourceArn
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The Amazon Resource Name (ARN) of the event source.",
		//	  "maxLength": 1024,
		//	  "minLength": 12,
		//	  "pattern": "arn:(aws[a-zA-Z0-9-]*):([a-zA-Z0-9\\-])+:([a-z]{2}(-gov)?-[a-z]+-\\d{1})?:(\\d{12})?:(.*)",
		//	  "type": "string"
		//	}
		"event_source_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The Amazon Resource Name (ARN) of the event source.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: FilterCriteria
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The filter criteria to control event filtering.",
		//	  "properties": {
		//	    "Filters": {
		//	      "description": "List of filters of this FilterCriteria",
		//	      "items": {
		//	        "additionalProperties": false,
		//	        "description": "The filter object that defines parameters for ESM filtering.",
		//	        "properties": {
		//	          "Pattern": {
		//	            "description": "The filter pattern that defines which events should be passed for invocations.",
		//	            "maxLength": 4096,
		//	            "minLength": 0,
		//	            "pattern": ".*",
		//	            "type": "string"
		//	          }
		//	        },
		//	        "type": "object"
		//	      },
		//	      "maxItems": 20,
		//	      "minItems": 1,
		//	      "type": "array",
		//	      "uniqueItems": true
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"filter_criteria": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Filters
				"filters": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
					NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
						Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
							// Property: Pattern
							"pattern": schema.StringAttribute{ /*START ATTRIBUTE*/
								Description: "The filter pattern that defines which events should be passed for invocations.",
								Computed:    true,
							}, /*END ATTRIBUTE*/
						}, /*END SCHEMA*/
					}, /*END NESTED OBJECT*/
					Description: "List of filters of this FilterCriteria",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The filter criteria to control event filtering.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: FunctionName
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the Lambda function.",
		//	  "maxLength": 140,
		//	  "minLength": 1,
		//	  "pattern": "(arn:(aws[a-zA-Z-]*)?:lambda:)?([a-z]{2}(-gov)?-[a-z]+-\\d{1}:)?(\\d{12}:)?(function:)?([a-zA-Z0-9-_]+)(:(\\$LATEST|[a-zA-Z0-9-_]+))?",
		//	  "type": "string"
		//	}
		"function_name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the Lambda function.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: FunctionResponseTypes
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Streams) A list of response types supported by the function.",
		//	  "items": {
		//	    "enum": [
		//	      "ReportBatchItemFailures"
		//	    ],
		//	    "type": "string"
		//	  },
		//	  "maxLength": 1,
		//	  "minLength": 0,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"function_response_types": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "(Streams) A list of response types supported by the function.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Id
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Event Source Mapping Identifier UUID.",
		//	  "maxLength": 36,
		//	  "minLength": 36,
		//	  "pattern": "[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}",
		//	  "type": "string"
		//	}
		"id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Event Source Mapping Identifier UUID.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: MaximumBatchingWindowInSeconds
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Streams) The maximum amount of time to gather records before invoking the function, in seconds.",
		//	  "maximum": 300,
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"maximum_batching_window_in_seconds": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "(Streams) The maximum amount of time to gather records before invoking the function, in seconds.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: MaximumRecordAgeInSeconds
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Streams) The maximum age of a record that Lambda sends to a function for processing.",
		//	  "maximum": 604800,
		//	  "minimum": -1,
		//	  "type": "integer"
		//	}
		"maximum_record_age_in_seconds": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "(Streams) The maximum age of a record that Lambda sends to a function for processing.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: MaximumRetryAttempts
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Streams) The maximum number of times to retry when the function returns an error.",
		//	  "maximum": 10000,
		//	  "minimum": -1,
		//	  "type": "integer"
		//	}
		"maximum_retry_attempts": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "(Streams) The maximum number of times to retry when the function returns an error.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ParallelizationFactor
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Streams) The number of batches to process from each shard concurrently.",
		//	  "maximum": 10,
		//	  "minimum": 1,
		//	  "type": "integer"
		//	}
		"parallelization_factor": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "(Streams) The number of batches to process from each shard concurrently.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Queues
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(ActiveMQ) A list of ActiveMQ queues.",
		//	  "items": {
		//	    "maxLength": 1000,
		//	    "minLength": 1,
		//	    "pattern": "[\\s\\S]*",
		//	    "type": "string"
		//	  },
		//	  "maxItems": 1,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"queues": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "(ActiveMQ) A list of ActiveMQ queues.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: ScalingConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "The scaling configuration for the event source.",
		//	  "properties": {
		//	    "MaximumConcurrency": {
		//	      "description": "The maximum number of concurrent functions that the event source can invoke.",
		//	      "maximum": 1000,
		//	      "minimum": 2,
		//	      "type": "integer"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"scaling_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: MaximumConcurrency
				"maximum_concurrency": schema.Int64Attribute{ /*START ATTRIBUTE*/
					Description: "The maximum number of concurrent functions that the event source can invoke.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "The scaling configuration for the event source.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: SelfManagedEventSource
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Self-managed event source endpoints.",
		//	  "properties": {
		//	    "Endpoints": {
		//	      "additionalProperties": false,
		//	      "description": "The endpoints for a self-managed event source.",
		//	      "properties": {
		//	        "KafkaBootstrapServers": {
		//	          "description": "A list of Kafka server endpoints.",
		//	          "items": {
		//	            "description": "The URL of a Kafka server.",
		//	            "maxLength": 300,
		//	            "minLength": 1,
		//	            "pattern": "^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9]):[0-9]{1,5}",
		//	            "type": "string"
		//	          },
		//	          "maxItems": 10,
		//	          "minItems": 1,
		//	          "type": "array",
		//	          "uniqueItems": true
		//	        }
		//	      },
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"self_managed_event_source": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: Endpoints
				"endpoints": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: KafkaBootstrapServers
						"kafka_bootstrap_servers": schema.ListAttribute{ /*START ATTRIBUTE*/
							ElementType: types.StringType,
							Description: "A list of Kafka server endpoints.",
							Computed:    true,
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "The endpoints for a self-managed event source.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Self-managed event source endpoints.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: SelfManagedKafkaEventSourceConfig
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Specific configuration settings for a Self-Managed Apache Kafka event source.",
		//	  "properties": {
		//	    "ConsumerGroupId": {
		//	      "description": "The identifier for the Kafka Consumer Group to join.",
		//	      "maxLength": 200,
		//	      "minLength": 1,
		//	      "pattern": "[a-zA-Z0-9-\\/*:_+=.@-]*",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"self_managed_kafka_event_source_config": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ConsumerGroupId
				"consumer_group_id": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The identifier for the Kafka Consumer Group to join.",
					Computed:    true,
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Specific configuration settings for a Self-Managed Apache Kafka event source.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: SourceAccessConfigurations
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "A list of SourceAccessConfiguration.",
		//	  "items": {
		//	    "additionalProperties": false,
		//	    "description": "The configuration used by AWS Lambda to access event source",
		//	    "properties": {
		//	      "Type": {
		//	        "description": "The type of source access configuration.",
		//	        "enum": [
		//	          "BASIC_AUTH",
		//	          "VPC_SUBNET",
		//	          "VPC_SECURITY_GROUP",
		//	          "SASL_SCRAM_512_AUTH",
		//	          "SASL_SCRAM_256_AUTH",
		//	          "VIRTUAL_HOST",
		//	          "CLIENT_CERTIFICATE_TLS_AUTH",
		//	          "SERVER_ROOT_CA_CERTIFICATE"
		//	        ],
		//	        "type": "string"
		//	      },
		//	      "URI": {
		//	        "description": "The URI for the source access configuration resource.",
		//	        "maxLength": 200,
		//	        "minLength": 1,
		//	        "pattern": "[a-zA-Z0-9-\\/*:_+=.@-]*",
		//	        "type": "string"
		//	      }
		//	    },
		//	    "type": "object"
		//	  },
		//	  "maxItems": 22,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"source_access_configurations": schema.ListNestedAttribute{ /*START ATTRIBUTE*/
			NestedObject: schema.NestedAttributeObject{ /*START NESTED OBJECT*/
				Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
					// Property: Type
					"type": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The type of source access configuration.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
					// Property: URI
					"uri": schema.StringAttribute{ /*START ATTRIBUTE*/
						Description: "The URI for the source access configuration resource.",
						Computed:    true,
					}, /*END ATTRIBUTE*/
				}, /*END SCHEMA*/
			}, /*END NESTED OBJECT*/
			Description: "A list of SourceAccessConfiguration.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: StartingPosition
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Streams sources.",
		//	  "maxLength": 12,
		//	  "minLength": 6,
		//	  "pattern": "(LATEST|TRIM_HORIZON|AT_TIMESTAMP)+",
		//	  "type": "string"
		//	}
		"starting_position": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The position in a stream from which to start reading. Required for Amazon Kinesis and Amazon DynamoDB Streams sources.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: StartingPositionTimestamp
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "With StartingPosition set to AT_TIMESTAMP, the time from which to start reading, in Unix time seconds.",
		//	  "type": "number"
		//	}
		"starting_position_timestamp": schema.Float64Attribute{ /*START ATTRIBUTE*/
			Description: "With StartingPosition set to AT_TIMESTAMP, the time from which to start reading, in Unix time seconds.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: Topics
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Kafka) A list of Kafka topics.",
		//	  "items": {
		//	    "maxLength": 249,
		//	    "minLength": 1,
		//	    "pattern": "^[^.]([a-zA-Z0-9\\-_.]+)",
		//	    "type": "string"
		//	  },
		//	  "maxItems": 1,
		//	  "minItems": 1,
		//	  "type": "array",
		//	  "uniqueItems": true
		//	}
		"topics": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "(Kafka) A list of Kafka topics.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
		// Property: TumblingWindowInSeconds
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "(Streams) Tumbling window (non-overlapping time window) duration to perform aggregations.",
		//	  "maximum": 900,
		//	  "minimum": 0,
		//	  "type": "integer"
		//	}
		"tumbling_window_in_seconds": schema.Int64Attribute{ /*START ATTRIBUTE*/
			Description: "(Streams) Tumbling window (non-overlapping time window) duration to perform aggregations.",
			Computed:    true,
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Required:    true,
	}

	schema := schema.Schema{
		Description: "Data Source schema for AWS::Lambda::EventSourceMapping",
		Attributes:  attributes,
	}

	var opts generic.DataSourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::Lambda::EventSourceMapping").WithTerraformTypeName("awscc_lambda_event_source_mapping")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"amazon_managed_kafka_event_source_config": "AmazonManagedKafkaEventSourceConfig",
		"batch_size":                             "BatchSize",
		"bisect_batch_on_function_error":         "BisectBatchOnFunctionError",
		"collection_name":                        "CollectionName",
		"consumer_group_id":                      "ConsumerGroupId",
		"database_name":                          "DatabaseName",
		"destination":                            "Destination",
		"destination_config":                     "DestinationConfig",
		"document_db_event_source_config":        "DocumentDBEventSourceConfig",
		"enabled":                                "Enabled",
		"endpoints":                              "Endpoints",
		"event_source_arn":                       "EventSourceArn",
		"event_source_mapping_id":                "Id",
		"filter_criteria":                        "FilterCriteria",
		"filters":                                "Filters",
		"full_document":                          "FullDocument",
		"function_name":                          "FunctionName",
		"function_response_types":                "FunctionResponseTypes",
		"kafka_bootstrap_servers":                "KafkaBootstrapServers",
		"maximum_batching_window_in_seconds":     "MaximumBatchingWindowInSeconds",
		"maximum_concurrency":                    "MaximumConcurrency",
		"maximum_record_age_in_seconds":          "MaximumRecordAgeInSeconds",
		"maximum_retry_attempts":                 "MaximumRetryAttempts",
		"on_failure":                             "OnFailure",
		"parallelization_factor":                 "ParallelizationFactor",
		"pattern":                                "Pattern",
		"queues":                                 "Queues",
		"scaling_config":                         "ScalingConfig",
		"self_managed_event_source":              "SelfManagedEventSource",
		"self_managed_kafka_event_source_config": "SelfManagedKafkaEventSourceConfig",
		"source_access_configurations":           "SourceAccessConfigurations",
		"starting_position":                      "StartingPosition",
		"starting_position_timestamp":            "StartingPositionTimestamp",
		"topics":                                 "Topics",
		"tumbling_window_in_seconds":             "TumblingWindowInSeconds",
		"type":                                   "Type",
		"uri":                                    "URI",
	})

	v, err := generic.NewSingularDataSource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
