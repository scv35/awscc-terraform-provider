// Code generated by generators/singular-data-source/main.go; DO NOT EDIT.

package ec2

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	. "github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddDataSourceTypeFactory("awscc_ec2_network_acl_entry", networkAclEntryDataSourceType)
}

// networkAclEntryDataSourceType returns the Terraform awscc_ec2_network_acl_entry data source type.
// This Terraform data source type corresponds to the CloudFormation AWS::EC2::NetworkAclEntry resource type.
func networkAclEntryDataSourceType(ctx context.Context) (tfsdk.DataSourceType, error) {
	attributes := map[string]tfsdk.Attribute{
		"cidr_block": {
			// Property: CidrBlock
			// CloudFormation resource type schema:
			// {
			//   "description": "The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the CidrBlock or Ipv6CidrBlock property",
			//   "type": "string"
			// }
			Description: "The IPv4 CIDR range to allow or deny, in CIDR notation (for example, 172.16.0.0/24). Requirement is conditional: You must specify the CidrBlock or Ipv6CidrBlock property",
			Type:        types.StringType,
			Computed:    true,
		},
		"egress": {
			// Property: Egress
			// CloudFormation resource type schema:
			// {
			//   "description": "Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet)",
			//   "type": "boolean"
			// }
			Description: "Indicates whether this is an egress rule (rule is applied to traffic leaving the subnet)",
			Type:        types.BoolType,
			Computed:    true,
		},
		"icmp": {
			// Property: Icmp
			// CloudFormation resource type schema:
			// {
			//   "additionalProperties": false,
			//   "properties": {
			//     "Code": {
			//       "type": "integer"
			//     },
			//     "Type": {
			//       "type": "integer"
			//     }
			//   },
			//   "type": "object"
			// }
			Attributes: tfsdk.SingleNestedAttributes(
				map[string]tfsdk.Attribute{
					"code": {
						// Property: Code
						Type:     types.NumberType,
						Computed: true,
					},
					"type": {
						// Property: Type
						Type:     types.NumberType,
						Computed: true,
					},
				},
			),
			Computed: true,
		},
		"id": {
			// Property: Id
			// CloudFormation resource type schema:
			// {
			//   "type": "string"
			// }
			Type:     types.StringType,
			Computed: true,
		},
		"ipv_6_cidr_block": {
			// Property: Ipv6CidrBlock
			// CloudFormation resource type schema:
			// {
			//   "description": "The IPv6 network range to allow or deny, in CIDR notation (for example 2001:db8:1234:1a00::/64)",
			//   "type": "string"
			// }
			Description: "The IPv6 network range to allow or deny, in CIDR notation (for example 2001:db8:1234:1a00::/64)",
			Type:        types.StringType,
			Computed:    true,
		},
		"network_acl_id": {
			// Property: NetworkAclId
			// CloudFormation resource type schema:
			// {
			//   "description": "The ID of the network ACL",
			//   "type": "string"
			// }
			Description: "The ID of the network ACL",
			Type:        types.StringType,
			Computed:    true,
		},
		"port_range": {
			// Property: PortRange
			// CloudFormation resource type schema:
			// {
			//   "additionalProperties": false,
			//   "properties": {
			//     "From": {
			//       "type": "integer"
			//     },
			//     "To": {
			//       "type": "integer"
			//     }
			//   },
			//   "type": "object"
			// }
			Attributes: tfsdk.SingleNestedAttributes(
				map[string]tfsdk.Attribute{
					"from": {
						// Property: From
						Type:     types.NumberType,
						Computed: true,
					},
					"to": {
						// Property: To
						Type:     types.NumberType,
						Computed: true,
					},
				},
			),
			Computed: true,
		},
		"protocol": {
			// Property: Protocol
			// CloudFormation resource type schema:
			// {
			//   "description": "The protocol number. A value of \"-1\" means all protocols. If you specify \"-1\" or a protocol number other than \"6\" (TCP), \"17\" (UDP), or \"1\" (ICMP), traffic on all ports is allowed, regardless of any ports or ICMP types or codes that you specify. If you specify protocol \"58\" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol \"58\" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code",
			//   "type": "integer"
			// }
			Description: "The protocol number. A value of \"-1\" means all protocols. If you specify \"-1\" or a protocol number other than \"6\" (TCP), \"17\" (UDP), or \"1\" (ICMP), traffic on all ports is allowed, regardless of any ports or ICMP types or codes that you specify. If you specify protocol \"58\" (ICMPv6) and specify an IPv4 CIDR block, traffic for all ICMP types and codes allowed, regardless of any that you specify. If you specify protocol \"58\" (ICMPv6) and specify an IPv6 CIDR block, you must specify an ICMP type and code",
			Type:        types.NumberType,
			Computed:    true,
		},
		"rule_action": {
			// Property: RuleAction
			// CloudFormation resource type schema:
			// {
			//   "description": "Indicates whether to allow or deny the traffic that matches the rule",
			//   "type": "string"
			// }
			Description: "Indicates whether to allow or deny the traffic that matches the rule",
			Type:        types.StringType,
			Computed:    true,
		},
		"rule_number": {
			// Property: RuleNumber
			// CloudFormation resource type schema:
			// {
			//   "description": "Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule",
			//   "type": "integer"
			// }
			Description: "Rule number to assign to the entry, such as 100. ACL entries are processed in ascending order by rule number. Entries can't use the same rule number unless one is an egress rule and the other is an ingress rule",
			Type:        types.NumberType,
			Computed:    true,
		},
	}

	attributes["id"] = tfsdk.Attribute{
		Description: "Uniquely identifies the resource.",
		Type:        types.StringType,
		Required:    true,
	}

	schema := tfsdk.Schema{
		Description: "Data Source schema for AWS::EC2::NetworkAclEntry",
		Version:     1,
		Attributes:  attributes,
	}

	var opts DataSourceTypeOptions

	opts = opts.WithCloudFormationTypeName("AWS::EC2::NetworkAclEntry").WithTerraformTypeName("awscc_ec2_network_acl_entry")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"cidr_block":       "CidrBlock",
		"code":             "Code",
		"egress":           "Egress",
		"from":             "From",
		"icmp":             "Icmp",
		"id":               "Id",
		"ipv_6_cidr_block": "Ipv6CidrBlock",
		"network_acl_id":   "NetworkAclId",
		"port_range":       "PortRange",
		"protocol":         "Protocol",
		"rule_action":      "RuleAction",
		"rule_number":      "RuleNumber",
		"to":               "To",
		"type":             "Type",
	})

	singularDataSourceType, err := NewSingularDataSourceType(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return singularDataSourceType, nil
}
