// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

// Code generated by generators/resource/main.go; DO NOT EDIT.

package bedrock

import (
	"context"
	"regexp"

	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-awscc/internal/generic"
	"github.com/hashicorp/terraform-provider-awscc/internal/registry"
)

func init() {
	registry.AddResourceFactory("awscc_bedrock_data_source", dataSourceResource)
}

// dataSourceResource returns the Terraform awscc_bedrock_data_source resource.
// This Terraform resource corresponds to the CloudFormation AWS::Bedrock::DataSource resource.
func dataSourceResource(ctx context.Context) (resource.Resource, error) {
	attributes := map[string]schema.Attribute{ /*START SCHEMA*/
		// Property: CreatedAt
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The time at which the data source was created.",
		//	  "type": "string"
		//	}
		"created_at": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The time at which the data source was created.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DataDeletionPolicy
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The deletion policy for the data source.",
		//	  "enum": [
		//	    "RETAIN",
		//	    "DELETE"
		//	  ],
		//	  "type": "string"
		//	}
		"data_deletion_policy": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The deletion policy for the data source.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.OneOf(
					"RETAIN",
					"DELETE",
				),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DataSourceConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Specifies a raw data source location to ingest.",
		//	  "properties": {
		//	    "S3Configuration": {
		//	      "additionalProperties": false,
		//	      "description": "Contains information about the S3 configuration of the data source.",
		//	      "properties": {
		//	        "BucketArn": {
		//	          "description": "The ARN of the bucket that contains the data source.",
		//	          "maxLength": 2048,
		//	          "minLength": 1,
		//	          "pattern": "^arn:aws(|-cn|-us-gov):s3:::[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$",
		//	          "type": "string"
		//	        },
		//	        "BucketOwnerAccountId": {
		//	          "description": "The account ID for the owner of the S3 bucket.",
		//	          "maxLength": 12,
		//	          "minLength": 12,
		//	          "pattern": "^[0-9]{12}$",
		//	          "type": "string"
		//	        },
		//	        "InclusionPrefixes": {
		//	          "description": "A list of S3 prefixes that define the object containing the data sources.",
		//	          "insertionOrder": false,
		//	          "items": {
		//	            "description": "Prefix for s3 object.",
		//	            "maxLength": 300,
		//	            "minLength": 1,
		//	            "type": "string"
		//	          },
		//	          "maxItems": 1,
		//	          "minItems": 1,
		//	          "type": "array"
		//	        }
		//	      },
		//	      "required": [
		//	        "BucketArn"
		//	      ],
		//	      "type": "object"
		//	    },
		//	    "Type": {
		//	      "description": "The type of the data source location.",
		//	      "enum": [
		//	        "S3"
		//	      ],
		//	      "type": "string"
		//	    }
		//	  },
		//	  "required": [
		//	    "Type",
		//	    "S3Configuration"
		//	  ],
		//	  "type": "object"
		//	}
		"data_source_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: S3Configuration
				"s3_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: BucketArn
						"bucket_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The ARN of the bucket that contains the data source.",
							Required:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(1, 2048),
								stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws(|-cn|-us-gov):s3:::[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$"), ""),
							}, /*END VALIDATORS*/
						}, /*END ATTRIBUTE*/
						// Property: BucketOwnerAccountId
						"bucket_owner_account_id": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "The account ID for the owner of the S3 bucket.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.LengthBetween(12, 12),
								stringvalidator.RegexMatches(regexp.MustCompile("^[0-9]{12}$"), ""),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
								stringplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
						// Property: InclusionPrefixes
						"inclusion_prefixes": schema.ListAttribute{ /*START ATTRIBUTE*/
							ElementType: types.StringType,
							Description: "A list of S3 prefixes that define the object containing the data sources.",
							Optional:    true,
							Computed:    true,
							Validators: []validator.List{ /*START VALIDATORS*/
								listvalidator.SizeBetween(1, 1),
								listvalidator.ValueStringsAre(
									stringvalidator.LengthBetween(1, 300),
								),
							}, /*END VALIDATORS*/
							PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
								generic.Multiset(),
								listplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Contains information about the S3 configuration of the data source.",
					Required:    true,
				}, /*END ATTRIBUTE*/
				// Property: Type
				"type": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The type of the data source location.",
					Required:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.OneOf(
							"S3",
						),
					}, /*END VALIDATORS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Specifies a raw data source location to ingest.",
			Required:    true,
		}, /*END ATTRIBUTE*/
		// Property: DataSourceId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Identifier for a resource.",
		//	  "pattern": "^[0-9a-zA-Z]{10}$",
		//	  "type": "string"
		//	}
		"data_source_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Identifier for a resource.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: DataSourceStatus
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The status of a data source.",
		//	  "enum": [
		//	    "AVAILABLE",
		//	    "DELETING",
		//	    "DELETE_UNSUCCESSFUL"
		//	  ],
		//	  "type": "string"
		//	}
		"data_source_status": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The status of a data source.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Description
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "Description of the Resource.",
		//	  "maxLength": 200,
		//	  "minLength": 1,
		//	  "type": "string"
		//	}
		"description": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "Description of the Resource.",
			Optional:    true,
			Computed:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.LengthBetween(1, 200),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: FailureReasons
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The details of the failure reasons related to the data source.",
		//	  "insertionOrder": false,
		//	  "items": {
		//	    "description": "Failure Reason for Error.",
		//	    "maxLength": 2048,
		//	    "type": "string"
		//	  },
		//	  "maxItems": 2048,
		//	  "type": "array"
		//	}
		"failure_reasons": schema.ListAttribute{ /*START ATTRIBUTE*/
			ElementType: types.StringType,
			Description: "The details of the failure reasons related to the data source.",
			Computed:    true,
			PlanModifiers: []planmodifier.List{ /*START PLAN MODIFIERS*/
				generic.Multiset(),
				listplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: KnowledgeBaseId
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The unique identifier of the knowledge base to which to add the data source.",
		//	  "pattern": "^[0-9a-zA-Z]{10}$",
		//	  "type": "string"
		//	}
		"knowledge_base_id": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The unique identifier of the knowledge base to which to add the data source.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("^[0-9a-zA-Z]{10}$"), ""),
			}, /*END VALIDATORS*/
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.RequiresReplace(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: Name
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The name of the data source.",
		//	  "pattern": "^([0-9a-zA-Z][_-]?){1,100}$",
		//	  "type": "string"
		//	}
		"name": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The name of the data source.",
			Required:    true,
			Validators: []validator.String{ /*START VALIDATORS*/
				stringvalidator.RegexMatches(regexp.MustCompile("^([0-9a-zA-Z][_-]?){1,100}$"), ""),
			}, /*END VALIDATORS*/
		}, /*END ATTRIBUTE*/
		// Property: ServerSideEncryptionConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Contains details about the server-side encryption for the data source.",
		//	  "properties": {
		//	    "KmsKeyArn": {
		//	      "description": "The ARN of the AWS KMS key used to encrypt the resource.",
		//	      "maxLength": 2048,
		//	      "minLength": 1,
		//	      "pattern": "^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$",
		//	      "type": "string"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"server_side_encryption_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: KmsKeyArn
				"kms_key_arn": schema.StringAttribute{ /*START ATTRIBUTE*/
					Description: "The ARN of the AWS KMS key used to encrypt the resource.",
					Optional:    true,
					Computed:    true,
					Validators: []validator.String{ /*START VALIDATORS*/
						stringvalidator.LengthBetween(1, 2048),
						stringvalidator.RegexMatches(regexp.MustCompile("^arn:aws(|-cn|-us-gov):kms:[a-zA-Z0-9-]*:[0-9]{12}:key/[a-zA-Z0-9-]{36}$"), ""),
					}, /*END VALIDATORS*/
					PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
						stringplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Contains details about the server-side encryption for the data source.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: UpdatedAt
		// CloudFormation resource type schema:
		//
		//	{
		//	  "description": "The time at which the knowledge base was last updated.",
		//	  "type": "string"
		//	}
		"updated_at": schema.StringAttribute{ /*START ATTRIBUTE*/
			Description: "The time at which the knowledge base was last updated.",
			Computed:    true,
			PlanModifiers: []planmodifier.String{ /*START PLAN MODIFIERS*/
				stringplanmodifier.UseStateForUnknown(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
		// Property: VectorIngestionConfiguration
		// CloudFormation resource type schema:
		//
		//	{
		//	  "additionalProperties": false,
		//	  "description": "Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.",
		//	  "properties": {
		//	    "ChunkingConfiguration": {
		//	      "additionalProperties": false,
		//	      "description": "Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.",
		//	      "properties": {
		//	        "ChunkingStrategy": {
		//	          "description": "Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.",
		//	          "enum": [
		//	            "FIXED_SIZE",
		//	            "NONE"
		//	          ],
		//	          "type": "string"
		//	        },
		//	        "FixedSizeChunkingConfiguration": {
		//	          "additionalProperties": false,
		//	          "description": "Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.",
		//	          "properties": {
		//	            "MaxTokens": {
		//	              "description": "The maximum number of tokens to include in a chunk.",
		//	              "minimum": 1,
		//	              "type": "integer"
		//	            },
		//	            "OverlapPercentage": {
		//	              "description": "The percentage of overlap between adjacent chunks of a data source.",
		//	              "maximum": 99,
		//	              "minimum": 1,
		//	              "type": "integer"
		//	            }
		//	          },
		//	          "required": [
		//	            "MaxTokens",
		//	            "OverlapPercentage"
		//	          ],
		//	          "type": "object"
		//	        }
		//	      },
		//	      "required": [
		//	        "ChunkingStrategy"
		//	      ],
		//	      "type": "object"
		//	    }
		//	  },
		//	  "type": "object"
		//	}
		"vector_ingestion_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
			Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
				// Property: ChunkingConfiguration
				"chunking_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
					Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
						// Property: ChunkingStrategy
						"chunking_strategy": schema.StringAttribute{ /*START ATTRIBUTE*/
							Description: "Knowledge base can split your source data into chunks. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for NONE, then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.",
							Required:    true,
							Validators: []validator.String{ /*START VALIDATORS*/
								stringvalidator.OneOf(
									"FIXED_SIZE",
									"NONE",
								),
							}, /*END VALIDATORS*/
						}, /*END ATTRIBUTE*/
						// Property: FixedSizeChunkingConfiguration
						"fixed_size_chunking_configuration": schema.SingleNestedAttribute{ /*START ATTRIBUTE*/
							Attributes: map[string]schema.Attribute{ /*START SCHEMA*/
								// Property: MaxTokens
								"max_tokens": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "The maximum number of tokens to include in a chunk.",
									Required:    true,
									Validators: []validator.Int64{ /*START VALIDATORS*/
										int64validator.AtLeast(1),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
								// Property: OverlapPercentage
								"overlap_percentage": schema.Int64Attribute{ /*START ATTRIBUTE*/
									Description: "The percentage of overlap between adjacent chunks of a data source.",
									Required:    true,
									Validators: []validator.Int64{ /*START VALIDATORS*/
										int64validator.Between(1, 99),
									}, /*END VALIDATORS*/
								}, /*END ATTRIBUTE*/
							}, /*END SCHEMA*/
							Description: "Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.",
							Optional:    true,
							Computed:    true,
							PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
								objectplanmodifier.UseStateForUnknown(),
							}, /*END PLAN MODIFIERS*/
						}, /*END ATTRIBUTE*/
					}, /*END SCHEMA*/
					Description: "Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.",
					Optional:    true,
					Computed:    true,
					PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
						objectplanmodifier.UseStateForUnknown(),
					}, /*END PLAN MODIFIERS*/
				}, /*END ATTRIBUTE*/
			}, /*END SCHEMA*/
			Description: "Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.",
			Optional:    true,
			Computed:    true,
			PlanModifiers: []planmodifier.Object{ /*START PLAN MODIFIERS*/
				objectplanmodifier.UseStateForUnknown(),
				objectplanmodifier.RequiresReplaceIfConfigured(),
			}, /*END PLAN MODIFIERS*/
		}, /*END ATTRIBUTE*/
	} /*END SCHEMA*/

	// Corresponds to CloudFormation primaryIdentifier.
	attributes["id"] = schema.StringAttribute{
		Description: "Uniquely identifies the resource.",
		Computed:    true,
		PlanModifiers: []planmodifier.String{
			stringplanmodifier.UseStateForUnknown(),
		},
	}

	schema := schema.Schema{
		Description: "Definition of AWS::Bedrock::DataSource Resource Type",
		Version:     1,
		Attributes:  attributes,
	}

	var opts generic.ResourceOptions

	opts = opts.WithCloudFormationTypeName("AWS::Bedrock::DataSource").WithTerraformTypeName("awscc_bedrock_data_source")
	opts = opts.WithTerraformSchema(schema)
	opts = opts.WithAttributeNameMap(map[string]string{
		"bucket_arn":                           "BucketArn",
		"bucket_owner_account_id":              "BucketOwnerAccountId",
		"chunking_configuration":               "ChunkingConfiguration",
		"chunking_strategy":                    "ChunkingStrategy",
		"created_at":                           "CreatedAt",
		"data_deletion_policy":                 "DataDeletionPolicy",
		"data_source_configuration":            "DataSourceConfiguration",
		"data_source_id":                       "DataSourceId",
		"data_source_status":                   "DataSourceStatus",
		"description":                          "Description",
		"failure_reasons":                      "FailureReasons",
		"fixed_size_chunking_configuration":    "FixedSizeChunkingConfiguration",
		"inclusion_prefixes":                   "InclusionPrefixes",
		"kms_key_arn":                          "KmsKeyArn",
		"knowledge_base_id":                    "KnowledgeBaseId",
		"max_tokens":                           "MaxTokens",
		"name":                                 "Name",
		"overlap_percentage":                   "OverlapPercentage",
		"s3_configuration":                     "S3Configuration",
		"server_side_encryption_configuration": "ServerSideEncryptionConfiguration",
		"type":                                 "Type",
		"updated_at":                           "UpdatedAt",
		"vector_ingestion_configuration":       "VectorIngestionConfiguration",
	})

	opts = opts.WithCreateTimeoutInMinutes(0).WithDeleteTimeoutInMinutes(0)

	opts = opts.WithUpdateTimeoutInMinutes(0)

	v, err := generic.NewResource(ctx, opts...)

	if err != nil {
		return nil, err
	}

	return v, nil
}
